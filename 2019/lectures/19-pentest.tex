% !TeX program = XeLaTeX
\documentclass[10pt,xcolor={dvipsnames}]{beamer}

\usepackage{ragged2e}
\usepackage{fontspec}
% \usepackage{xcolor}
\usepackage{tikz}
\usepackage{listings}
% \usepackage{syntax}
\usepackage{semantic}
\usepackage{mathpartir}
\usepackage{stmaryrd}
\usepackage{amsmath}
\usepackage{xspace}
\usepackage{adjustbox}
% \usepackage{syntax}
\usepackage{xspace}
\usepackage{fitch}
\usepackage{algpseudocode}
\usepackage{mathtools}
\usepackage{array}
\usepackage{xcolor}
\usepackage{adjustbox}

\DeclarePairedDelimiterX{\infdivx}[2]{}{}{%
  [#1]\;\delimsize\|\;#2%
}
\newcommand{\infdiv}{D\infdivx}
\DeclarePairedDelimiter{\norm}{\lVert}{\rVert}

\input{template}

\usetikzlibrary{automata,shapes,positioning,matrix,shapes.callouts,decorations.text,patterns}

\tikzset{onslide/.code args={<#1>#2}{%
  \only<#1>{\pgfkeysalso{#2}} % \pgfkeysalso doesn't change the path
}}

\tikzset{
    invisible/.style={opacity=0,text opacity=0},
    visible on/.style={alt={#1{}{invisible}}},
    alt/.code args={<#1>#2#3}{%
      \alt<#1>{\pgfkeysalso{#2}}{\pgfkeysalso{#3}} % \pgfkeysalso doesn't change the path
    },
  }

\newcommand{\pred}{\ensuremath{\mathsf{Pred}}\xspace}
\newcommand{\post}{\ensuremath{\mathbf{Post}}\xspace}
\newcommand{\pre}{\ensuremath{\mathbf{Pre}}\xspace}
\newcommand{\ex}{\ensuremath{\mathbf{EX\ }}\xspace}
\newcommand{\eg}{\ensuremath{\mathbf{EG\ }}\xspace}
\newcommand{\ef}{\ensuremath{\mathbf{EF\ }}\xspace}
\newcommand{\ax}{\ensuremath{\mathbf{AX\ }}\xspace}
\newcommand{\ag}{\ensuremath{\mathbf{AG\ }}\xspace}
\newcommand{\af}{\ensuremath{\mathbf{AF\ }}\xspace}
\newcommand{\nextt}{\ensuremath{\mathbf{X\ }}\xspace}
\newcommand{\future}{\ensuremath{\mathbf{F\ }}\xspace}
\newcommand{\always}{\ensuremath{\mathbf{G\ }}\xspace}
\newcommand{\until}{\ensuremath{\mathbf{\ U\ }}\xspace}
\newcommand{\release}{\ensuremath{\mathbf{\ R\ }}\xspace}
\newcommand{\existpath}{\ensuremath{\mathbf{E\ }}\xspace}
\newcommand{\forallpath}{\ensuremath{\mathbf{A\ }}\xspace}
\newcommand{\cex}{\ensuremath{\pi_{\mathrm{cex}}}\xspace}

\newcommand{\rv}{\ensuremath{\mathit{rv}}\xspace}
\newcommand{\vc}{\ensuremath{\mathsf{vc}}\xspace}
\newcommand{\spost}{\ensuremath{\mathsf{sp}}\xspace}
\newcommand{\wlpre}{\ensuremath{\mathsf{wlp}}\xspace}
\newcommand{\wpre}{\ensuremath{\mathsf{wp}}\xspace}
\newcommand{\free}{\ensuremath{\mathit{free}}\xspace}
\newcommand{\vars}{\ensuremath{\mathit{vars}}\xspace}
\newcommand{\pvars}{\ensuremath{\mathit{pvars}}\xspace}
\newcommand{\lvars}{\ensuremath{\mathit{lvars}}\xspace}
\newcommand{\imp}{\ensuremath{\mathsf{Imp}}\xspace}
\newcommand{\aexp}{\ensuremath{\mathsf{AExp}}\xspace}
\newcommand{\bexp}{\ensuremath{\mathsf{BExp}}\xspace}
\newcommand{\com}{\ensuremath{\mathsf{Com}}\xspace}
\newcommand{\env}{\ensuremath{\mathsf{Env}}\xspace}
\newcommand{\var}{\ensuremath{\mathsf{Var}}\xspace}
\newcommand{\loc}{\ensuremath{\mathsf{Loc}}\xspace}
\newcommand{\cond}{\ensuremath{\mathsf{Cond}}\xspace}
\newcommand{\strue}{\ensuremath{\mathsf{true}}\xspace}
\newcommand{\sfalse}{\ensuremath{\mathsf{false}}\xspace}

\newcommand{\eqdef}{\stackrel{\mathclap{\tiny\mbox{def}}}{=}}
\newcommand{\arraytheory}{\ensuremath{T_\mathsf{A}}\xspace}
\newcommand{\eqtheory}{\ensuremath{T_\mathsf{E}}\xspace}
\newcommand{\axm}{\ensuremath{\mathcal{A}}\xspace}
\newcommand{\true}{\ensuremath{\mathit{true}}\xspace}
\newcommand{\false}{\ensuremath{\mathit{false}}\xspace}
% \newcommand{\undef}{\ensuremath{\mathit{undef}}\xspace}
\newcommand{\unit}{\ensuremath{\mathit{unit}}\xspace}
\newcommand{\sat}{\ensuremath{\mathit{sat}}\xspace}
\newcommand{\unsat}{\ensuremath{\mathit{unsat}}\xspace}

\title[Testing]{
\RaggedRight
  Software Foundations of Security \& Privacy \\
  \ 15315 Spring 2018 \\
  \ Lecture 19: \\
  \ Penetration Testing
}

\author[Matt Fredrikson, Jean Yang]{
  Matt Fredrikson \\
  mfredrik@cs.cmu.edu
}

\date{April 12, 2018}

\begin{document}
\setlength\abovedisplayskip{3pt}
\setlength\belowdisplayskip{3pt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\titlepage
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}

\frametitle{Today's lecture}


\begin{itemize}
\item Why are we discussing this topic? \\[1ex]
\pause\item Final lab overview and expectations \\[1ex]
\pause\item Penetration testing software apps \\[1ex]
\begin{enumerate}
\item Fuzz testing \\[1ex]
\item Concolic execution \\[1ex]
\end{enumerate}
\pause\item If time, tutorial on AFL and KLEE 
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}

\frametitle{Final lab}

Find and exploit bugs in others' code
\begin{itemize}
\pause\item Given three implementations of lab0-lab2
\item Find vulnerabilities that lead to security issues
\item For full credit: turn in at least three bugs\\[1em]
\end{itemize}

\pause Justify the security concern
\begin{itemize}
\item Explain what security goal is violated
\item Give proof-of-concept (PoC) exploit\\[1em]
\end{itemize}

\pause Explain how to fix it
\begin{itemize}
\item Don't need to implement a fix
\item Detailed account, implementable with minor additional effort\\[1em]
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}

\frametitle{What's a security bug?}

\textbf{Zero points} for correctness/availability bugs
\begin{itemize}
\item A crash is not enough!
\item Not relevant to the goals of previous labs\\[1em]
\end{itemize}

\pause Focus on things covered in class
\begin{itemize}
\item Safety: memory and control-flow
\item Confidentiality: Lab 2 policies, filesystem
\item Integrity: Host system should be unaffected\\[1em]
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}

\frametitle{How should you find them?}

Short answer: your choice
\\[1em]

\pause
You are free to use whatever tools you like
\begin{itemize}
\item Be creative, explore the landscape
\item But don't waste too much time on one tool\\[1em]
\end{itemize}

\pause
We have covered (or will) several in class
\begin{itemize}
\item CBMC
\item \texttt{afl-fuzz}
\item KLEE
\item PIN
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}

\frametitle{What to report}

For each vulnerability, submit a detailed report
\begin{enumerate}
\pause\item Identify and justify nature of vulnerability
\pause\item Explain how you found it---we should be able to reproduce!
\pause\item Show how you exploited it, give evidence that you did
\pause\item Explain in detail how to fix it (``fix the parser'' is not enough!) 
\pause\item Provide any code that you wrote
\\[1em]
\end{enumerate}

\pause
Each report should be approx. 2-3 pages
\\[1em]

\pause
\textbf{Key focus:} we need to reproduce your findings from the report!

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}

\frametitle{Grading}

Each report is worth 33 points
\begin{description}
\item[15 points.] Reproducible vulnerability
\item[10 points.] Correct fix given with adequate detail
\item[8 points.] Clear explanation of security issue\\[2em]
\end{description}

\pause
\textbf{Extra credit}
\begin{itemize}
\item Implement vulnerability fixes for your server
\item Depending on scope/difficulty, 5-10 points
\item Earn back missed points from previous labs!
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}

\frametitle{No bugs?}

What if you \emph{really} can't find a bug?
\\[1em]

\pause
Still potential for full points; report on:
\begin{itemize}
\pause\item Detailed steps you took to search
\pause\item What tools you used, and why
\pause\item Justification for your conclusion \\[2em]
\end{itemize}

\pause
\textbf{Convince us that there's nothing to exploit}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}

\frametitle{Hacking is bug-finding}

\textbf{successful attack = bug-finding + exploitation}
\\[1.5em]

\pause
How does one find bugs?
\begin{itemize}
\pause\item Manually inspecting source code, reasoning about correctness \\[0.5em]
\pause\item Attempting (and failing) verification \\[0.5em]
\pause\item Testing \\[1.5em]
\end{itemize}

\pause
Advanced testing techniques are widely used in security research
\begin{itemize}
\item Mandated in Microsoft's development lifecycle \\[0.5em]
\item E.g. fuzzing uncovers ``million dollar bugs'' in real systems \\[1.5em]
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}

\frametitle{Systematic testing}

Want to be systematic in how we go about testing
\\[1em]

This requires answers to the following questions:
\begin{itemize}
\item Which inputs do we choose?
\item How do we check the outputs?
\item When do we stop?
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}

\frametitle{Partitioning: which inputs to choose}

Can't test all inputs, random testing doesn't work (it's too random)
\\[1.5em]

We want to find a set of tests that:
\begin{enumerate}
\item is small enough to run \\[0.5em]
\item is likely to catch most of the bugs we care about \\[1.5em]
\end{enumerate}

\pause
\textbf{Intuition:} input space is very large, the program is limited
\begin{itemize}
\item program behavior must be ``similar'' on many inputs \\[0.5em]
\item identify ones yielding similar behavior, pick a representative test \\[0.5em]
\item make sure each input partition is covered by a test \\[1.5em]
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}

\frametitle{Identifying good partitions}

Partitions should correspond to relevant program properties
\begin{itemize}
\item Good test suite explores most of this space\\[1.5em]
\end{itemize}

\pause
Two basic approaches: \textbf{black-box} and \textbf{white-box}
\begin{itemize}
\item Black-box: as the name suggests, view the program as an opaque function and test to the specification\\[0.5em]
\item White-box: use knowledge of implementation \& code to generate representative tests and coverage metrics
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}

\frametitle{Black-box selection strategies}

\textbf{Enumerate ``paths'' through the specification}
\begin{itemize}
\item Use \texttt{requires}, \texttt{ensures}, failure/exception cases \\[0.5em]
\item Test each valid combination to cover all intended cases \\[0.5em]
\item Also: make sure the spec doesn't miss any possible inputs \\[1em]
\end{itemize}

\pause
\textbf{Test boundary/extremal values}
\begin{itemize}
\item Choose values close to low and high-end of valid range \\[0.5em]
\item e.g., integer range, buffer size, \ldots \\[0.5em]
\item Good exercise to find holes in the specification \\[1em]
\end{itemize}

\pause
\textbf{Off-nominal values}
\begin{itemize}
\item Identify invalid inputs, choose values that test each one \\[0.5em]
\item Break invariants and violate assumptions
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]

\frametitle{Example}

What are the relevant features of the \texttt{maximum} function?

\begin{lstlisting}[language=Caml]
(* if l is non-empty, returns the greatest element 
   if l is empty, returns None *)
let maximum (l : int list) : int option =
  ...
\end{lstlisting}

\begin{itemize}
\pause\item The size of the list (0, 1, 2, large, very large) \\[0.5em]
\pause\item Position of maximum value (beginning, middle, end) \\[0.5em]
\pause\item Range of values (negative, positive, max/min values) \\[0.5em]
\pause\item Existence of duplicate values \\[0.5em]
\pause\item Ordering of elements (ascending, descending, ``random'')
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}

\frametitle{White-box testing}

Use details of the implementation to design and evaluate tests
\begin{itemize}
\item Develop partitions to maximize \emph{code coverage} \\[0.5em]
\item Test internal features like caching, domain-splitting, etc. \\[1.5em]
\end{itemize}

\pause
Whitebox testing has its own advantages
\begin{enumerate}
\pause\item Tests are tailored to the code, easier to find certain bugs \\[0.5em]
\pause\item Possible to know when you've covered the implementation \\[0.5em]
\pause\item Can oftentimes be automated \\[1.5em]
\end{enumerate}

\pause
Disadvantages:
\begin{enumerate}
\pause\item Expensive, and still not verification \\[0.5em]
\pause\item Automated tools are language-dependent, rely on heuristics
\end{enumerate}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}

\frametitle{Coverage metrics: when to stop testing}

Goal is to make sure tests cover all the relevant code
\\[1em]

\pause
There are several ways to measure this
\begin{itemize}
\pause\item Statements
\item Branches
\item Paths
\item Traces
\item ... \\[1.5em]
\end{itemize}

\pause
Each offers a different tradeoff between cost and completeness

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]

\frametitle{Coverage criteria: statements}

\begin{columns}
\begin{column}{0.45\textwidth}
\textbf{Goal:} Design a test set such that each atomic command is executed at least once
\\[1em]

\pause
An atomic command contains no nested statements
\begin{itemize}
\item Assignments, function calls are examples of primitive statements \\[0.5em]
\item Loops, conditionals are not atomic \\[0.5em]
\end{itemize}
\end{column}

\begin{column}{0.55\textwidth}
\pause
\begin{lstlisting}[language=Caml]
let f (n: int ref) (c: int ref) =   
  while !c <> 0 do
    if !n > 100 then (
      n := !n - 10;
      c := !c - 1;
    ) else (
      n := !n + 11;
      c := !c + 1;
    );    
  done;
  !n
\end{lstlisting}
\end{column}

\end{columns}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]

\frametitle{Coverage criteria: statements}

\begin{columns}
\begin{column}{0.45\textwidth}
What test set achieves statement coverage?
\\[1em]

\pause
$(n = 101, c = 1)$?
\\
\pause
\ \ \ \ \emph{no}
\\[0.5em]

\pause
$(n = 101, c = 1),$
$(n = 100, c = 1)$?
\\
\pause
\ \ \ \ \emph{yes}
\\[0.5em]

\pause
$(n = 101, c = 2)$?
\\
\pause
\ \ \ \ \emph{yes}
\end{column}

\begin{column}{0.55\textwidth}
\onslide<1->
\begin{lstlisting}[language=Caml]
let f (n: int ref) (c: int ref) =   
  while !c <> 0 do
    if !n > 100 then (
      n := !n - 10;
      c := !c - 1;
    ) else (
      n := !n + 11;
      c := !c + 1;
    );    
  done;
  !n
\end{lstlisting}
\end{column}

\end{columns}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]

\frametitle{Coverage criteria: branches}

\begin{columns}
\begin{column}{0.45\textwidth}
\textbf{Goal:} Design a test set such that each branch is executed at least once
\\[1em]

\pause
Branching comes from several constructs:
\begin{itemize}
\pause\item conditional (if-then-else)
\item \texttt{match}/\texttt{case}
\item loops
\end{itemize}
\end{column}

\begin{column}{0.55\textwidth}
\onslide<1->
\begin{lstlisting}[language=Caml]
let f (n: int ref) (c: int ref) =   
  while !c <> 0 do
    if !n > 100 then (
      n := !n - 10;
      c := !c - 1;
    ) else (
      n := !n + 11;
      c := !c + 1;
    );    
  done;
  !n
\end{lstlisting}
\end{column}

\end{columns}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]

\frametitle{Coverage criteria: branches}

\begin{columns}
\begin{column}{0.45\textwidth}
What tests give us branch coverage?
\\[1em]

\pause
Same as before:
$(n = 101, c = 1),$
$(n = 100, c = 1)$
\\

$(n = 101, c = 2)$
\end{column}

\begin{column}{0.55\textwidth}
\onslide<1->
\begin{lstlisting}[language=Caml]
let f (n: int ref) (c: int ref) =   
  while !c <> 0 do
    if !n > 100 then (
      n := !n - 10;
      c := !c - 1;
    ) else (
      n := !n + 11;
      c := !c + 1;
    );    
  done;
  !n
\end{lstlisting}
\end{column}

\end{columns}

\end{frame}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{frame}[fragile]

% \frametitle{Coverage criteria: branches}

% \begin{columns}
% \begin{column}{0.45\textwidth}
% Is branch coverage the same as statement coverage?
% \\[1em]

% \pause
% \emph{No}
% \\[1em]

% \onslide<4->
% In this example:
% \begin{itemize}
% \item<4-> \texttt{c1 = true, c2 = true} covers all statements \\[0.5em]
% \item<5-> \texttt{c1 = false, c2 = false} hits already-covered statements, but fails
% \end{itemize}

% \end{column}

% \begin{column}{0.55\textwidth}
% \onslide<3->
% \begin{lstlisting}[language=Caml]
% if c1 then
%   f1();
% if c2 then 
%   f2();
% fail_if_f2_not_called();
% \end{lstlisting}

% \onslide<6->
% \vspace*{1.5em}
% Statement coverage:\\
% \texttt{c1 = true, c2 = true}
% \\[1em]

% Branch coverage:\\
% \texttt{c1 = true, c2 = true} \\
% \texttt{c1 = false, c2 = false} \\
% \emph{need both tests!}
% \end{column}

% \end{columns}

% \end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{frame}[fragile]

% \frametitle{Coverage criteria: conditions}

% \begin{columns}
% \begin{column}{0.45\textwidth}
% \textbf{Goal:} Design a test set such that each condition evaluates to both values
% \\[1em]

% \pause
% A condition is a Boolean expression appearing in a guarded statement
% \\[1.5em]

% \pause
% Want to ensure that each Boolean subexpression evaluates to \true and \false
% \end{column}

% \begin{column}{0.55\textwidth}
% \onslide<1->
% \begin{lstlisting}[language=Caml]
% if c1 then
%   f1();
% if c2 then 
%   f2();
% fail_if_f2_not_called();
% \end{lstlisting}

% \end{column}

% \end{columns}

% \end{frame}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{frame}[fragile]

% \frametitle{Coverage criteria: conditions}

% \begin{columns}
% \begin{column}{0.55\textwidth}
% Are branch and condition coverage always the same?
% \\[1em]

% \onslide<2->{\emph{No}\\[1em]}

% \begin{onlyenv}<4->
% In this example,
% \begin{itemize}
% \item Branch coverage: \\ \texttt{(true, false, true)}\\ \texttt{(false, false, false)}
% \pause\item Condition coverage: \\ \texttt{(true, false, true)}\\ \texttt{(false, true, false)}\\ \texttt{(false, false, true)}
% \end{itemize}
% \end{onlyenv}

% \end{column}

% \begin{column}{0.45\textwidth}
% \begin{onlyenv}<1-2>
% \begin{lstlisting}[language=Caml]
% if c1 then
%   f1();
% if c2 then 
%   f2();
% fail_if_f2_not_called();
% \end{lstlisting}
% \end{onlyenv}

% \begin{onlyenv}<3->
% \begin{lstlisting}[language=Caml]
% if (c1 || c2) then
%   f1();
% if c3 then 
%   f2();
% fail_if_c2_is_true();
% \end{lstlisting}  
% \end{onlyenv}

% \end{column}

% \end{columns}


% \end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]

\frametitle{Coverage criteria: paths}

\begin{columns}
\begin{column}{0.55\textwidth}
\textbf{Goal:} Design a test set such that each \emph{path} is executed
\\[1em]

A path is a sequence of statements in the program:
\begin{itemize}
\item that takes it from an entry point to termination \\[0.5em]
\item and follows the control-flow structure \\[1.5em]
\end{itemize}

\pause
How many paths are in this program?
\\[1em]

\pause
\emph{12}: $2^4$ - $\{\mathrm{duplicates\ from\ } \mathtt{c1 = 0}\}$

\end{column}

\begin{column}{0.45\textwidth}
\onslide<2->
\begin{lstlisting}[language=Caml]
if c1 then
  if c2 then
    f1();
  else
    f2();
if c3 then
  f3();
if c4 then
  f4();
\end{lstlisting}

\end{column}

\end{columns}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]

\frametitle{Coverage criteria: paths}

\begin{columns}

\begin{column}{0.55\textwidth}
% \begin{onlyenv}<1->
\begin{lstlisting}[language=Caml]
let f (n: int ref) (c: int ref) =   
  while !c <> 0 do
    if !n > 100 then (
      n := !n - 10;
      c := !c - 1;
    ) else (
      n := !n + 11;
      c := !c + 1;
    );    
  done;
  !n
\end{lstlisting}
% \end{onlyenv}
\end{column}

\begin{column}{0.45\textwidth}
How many paths are in this program?
\\[1em]

\onslide<2->
Too many to test
\begin{itemize}
\item<3-> Bounded by width of machine integer, squared \\[0.5em]
\item<4-> This ``bound'' isn't any better than exhaustive testing \\[1.5em]
\end{itemize}

\onslide<5->
Loops \& recursion make exhaustive path coverage infeasible
\end{column}


\end{columns}

\end{frame}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{frame}[fragile]

% \frametitle{Weaknesses of coverage criteria}

% \begin{columns}
% \begin{column}{0.6\textwidth}
% We can roughly order criteria by level of ``confidence'':
% \[
% \begin{array}{l}
% %
% \mathrm{statement} < \mathrm{branch} < \mathrm{path}
% \end{array}
% \]

% \onslide<2->
% \vspace*{1em}
% But testing is inherently an incomplete, heuristic measure
% \\[1em]

% Consider this flawed ``median'' function
% \\[1em]

% Good tests require careful thought and a good specification
% \end{column}

% \begin{column}{0.4\textwidth}
% \begin{onlyenv}<2->
% \begin{lstlisting}[language=Caml]
% let median x y z =
%   z
% \end{lstlisting}
% \end{onlyenv}

% \onslide<3->
% \vspace*{1em}
% We can achieve all-paths and still fail to test
% \\[0.25em]

% \ \ \ \texttt{x = 3, y = 1, z = 2}
% \\[1em]

% \end{column}

% \end{columns}

% \end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}

\frametitle{Fuzz testing}

\begin{center}
\includegraphics{fuzzycat.jpg}
\end{center}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}

\frametitle{Fuzz testing}

\begin{exampleblock}{}
\small
Sitting in my apartment in Madison in the Fall of 1988, there was a wild midwest thunderstorm pouring rain and lighting up the late night sky. That night, I was logged on to the Unix system in my office via a dial-up phone line over a 1200 baud modem. With the heavy rain, there was noise on the line and that noise was interfering with my ability to type sensible commands to the shell and programs that I was running ... What did surprise me was the fact that the noise seemed to be causing programs to crash.
\vskip3mm
  \hspace*\fill{\small--- Prof. Bart Miller}
\end{exampleblock}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}

\frametitle{Fuzzing: what it's good for}

Simple idea: feed random inputs to the program, look for crashes/exceptions
\begin{itemize}
\item Works in blackbox, whitebox settings \\[0.5em]
\item Can be mostly random, or heavily influenced by existing tests or program internals \\[0.5em]
\item In either case, it's automated: lots of inputs, no regard for norms \\[1.5em]
\end{itemize}

\pause
Why is this an effective technique?
\begin{itemize}
\item Random processes make assumptions, have biases \\[0.5em]
\item Faults are good starting points for exploits \\[0.5em]
\item It works: Miller found bugs in 33\% of Unix utils
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}

\frametitle{Black-Box mechanics}

Inputs come from many sources
\begin{itemize}
\item Files, standard input, network, signals, devices, ... \\[1.5em]
\end{itemize}

\pause
Common strategy: intercept syscalls
\begin{itemize}
\item \texttt{open}, \texttt{read}, \texttt{send}, \texttt{ioctl} ... \\[1.5em]
\end{itemize}

\pause
Fuzzers measure coverage as they go
\begin{itemize}
\pause\item Most fuzzers instrument the target program \\[0.5em]
\pause\item Insert bookkeeping to count which instructions visited \\[0.5em]
\pause\item Best to rely on compiler for this, but can work on binaries
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}

\frametitle{Black-Box fuzzing: perturbation-based}

Given a program and an existing test:
\begin{itemize}
\item Perturb the test in various ways \\[0.5em]
\item E.g., flip bits, delete/append data \\[0.5em]
\item See if the program crashes on any values \\[1.5em]
\end{itemize}

\pause
This approach can be extended with heuristics.
\begin{itemize}
\item Which tests to use as seeds? \\[0.5em]
\item Strategies for perturbing seeds, ignoring certain types of input \\[1.5em]
\end{itemize}

\pause
What are the strengths and weaknesses?
\begin{enumerate}
\pause\item Easy to use, often finds serious bugs \\[0.5em]
\pause\item Test seeds can guide search towards less-random inputs \\[0.5em]
\pause\item Seeds may also bias towards assumptions \\[0.5em]
\pause\item Doesn't work well with checksums, grammars/protocols
\end{enumerate}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}

\frametitle{Black-Box fuzzing: generational}

Given a program and a format description:
\begin{enumerate}
\item Use the format to generate valid inputs \\[0.5em]
\item Iteratively perturb each location in the format \\[0.5em]
\item See if the program crashes on any values \\[0.5em]
\item Promote promising inputs to next generation \\[1.5em]
\end{enumerate}

\pause
This is a smarter way of inserting randomness
\begin{itemize}
\item Adhering mostly to the format ensures that early consistency/syntax checks are passed \\[0.5em]
\item Easier to achieve coverage, requires fewer test cases \\[1.5em]
\end{itemize}

\pause
What are the weaknesses?
\begin{enumerate}
\pause\item Need to provide info about format \\[0.5em]
\pause\item Format might not match the code, lead to missed bugs
\end{enumerate}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}

\frametitle{White-box fuzzing}

\begin{exampleblock}{Problem statement}
Given a program and a set of inputs, generate a test set that maximizes code coverage.
\end{exampleblock}

\pause
\vspace*{1em}
\textbf{Main idea:} Use the code itself to generate random inputs
\begin{enumerate}
\item Generate constraints that reflect the program's control flow \\[0.5em]
\item Solve the constraints, map solution to corresponding inputs \\[0.5em]
\item Run program on these inputs, look for crashes or exceptions \\[1.5em]
\end{enumerate}

This idea was pioneered by Patrice Godefroid at Microsoft

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]

\frametitle{Static test generation}

This isn't always possible
\\[1em]

\begin{columns}

\begin{column}{0.4\textwidth}
\begin{lstlisting}[language=Caml]
if x = SHA1(...) then
  if y > 3 then
    f1();
  else
    f2();
if x < y then
  f3();
if y > 3 && x >= y then
  f4();
\end{lstlisting}
\end{column}

\begin{column}{0.6\textwidth}

Second path: execute \texttt{f1, f3} \pause
\[
x = \mathtt{SHA1(\ldots)} \land y > 3 \land x < y \land \ldots
\]
\\[1em]

\pause
Solving requires finding \texttt{SHA} pre-image

\end{column}

\end{columns}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]

\frametitle{Dynamic symbolic test generation}

Generational testing\texttt{++}
\\[1em]

\pause
Given a program and test case:
\begin{enumerate}
\item Run the test case, and collect constraints along the tested path \\[0.5em]
\item Modify constraints by negating selected \emph{literals} \\[0.5em]
\item Solve new constraints, generate corresponding inputs \\[0.5em]
\item Repeat until all assertions are reached [Korel 1990, ...] \\[0.5em]
\item Or, generate inputs for all feasible paths [Godefroid et al 2005] \\[1.5em]
\end{enumerate}

\pause
This approach is called DART (\textbf{D}irected \textbf{A}utomated \textbf{R}andom \textbf{T}esting)

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]

\frametitle{Example}

\begin{columns}

\begin{column}{0.4\textwidth}
\begin{lstlisting}[language=Caml]
if x = SHA1(z) then
  if y > 3 then
    f1();
  else
    f2();
if x < y then
  f3();
if y > 3 && x >= y then
  f4();
\end{lstlisting}
\end{column}

\begin{column}{0.6\textwidth}

Start with \texttt{x = 5, y = 4, z = 0}
\\[1em]

Assume that $\mathtt{SHA1}(0) = 5$
\\[1em]
\pause

This yields the path:
\[
\begin{array}{l}
%
\mathtt{assume}(x = \mathtt{SHA1}(z)) \\
\mathtt{assume}(y > 3) \\
\mathtt{f1();} \\
\mathtt{assume}(\lnot(x < y)) \\
\mathtt{assume}(y > 3 \mathtt{\ \&\&\ } x \ge y) \\
\mathtt{f4()} \\
\end{array}
\]
\\[0.5em]

\pause
We can still explore \texttt{f2, f3} by changing $y$
\\[1em]

We fix $x$ and $z$, change other literals
\pause
\[
x = 5 \land z = 0 \land \lnot(y > 3) \land \lnot(x < y) \land \ldots
\]

\end{column}

\end{columns}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}

\frametitle{More intelligent search}

Start with a well-formed seed test
\\[1em]

\pause
Generate the path constraint
\begin{itemize}
\item Negate each literal independently \\[0.5em]
\item Generate a new test for each negation, add to test set \\[0.5em]
\item Repeat until resources run out, or we have path coverage \\[1.5em]
\end{itemize}

\pause
This approach tests many ``layers'' of the program early
\\[1em]

Contrast with classic depth-first approach

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}

\frametitle{Static test generation}

\includegraphics[width=\textwidth]{patrice.png}

\vspace*{1em}
\vfill

{\small
Example from Patrice Godefroid
}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]

\frametitle{DART implementations}

This approach has been used in many tools
\begin{itemize}
\item EXE (Stanford), concurrently with Godefroid's original work \\[0.5em]
\item CUTE (Bell Labs), concurrently with original work \\[0.5em]
\item SAGE (Microsoft Research) \\[0.5em]
\item PEX (Microsoft Research) \\[0.5em]
\item YOGI (Microsoft Research) \\[0.5em]
\item Vigilante (Microsoft Research) \\[0.5em]
\item BitScope (CMU/Berkeley) \\[0.5em]
\item CatchConv (Berkeley) \\[0.5em]
\item Splat (UCLA) \\[0.5em]
\item Apollo (MIT/IBM) \\[0.5em]
\end{itemize}

\end{frame}

\end{document}
